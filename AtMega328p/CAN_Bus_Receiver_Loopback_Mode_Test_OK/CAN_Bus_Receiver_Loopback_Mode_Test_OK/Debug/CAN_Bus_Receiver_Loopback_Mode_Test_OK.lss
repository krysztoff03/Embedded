
CAN_Bus_Receiver_Loopback_Mode_Test_OK.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000088  00800100  00000a84  00000b18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a84  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  00800188  00800188  00000ba0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ba0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000001e8  00000000  00000000  00000bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000020d8  00000000  00000000  00000db8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000ab1  00000000  00000000  00002e90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000013f8  00000000  00000000  00003941  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000474  00000000  00000000  00004d3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000606  00000000  00000000  000051b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000015b2  00000000  00000000  000057b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001b0  00000000  00000000  00006d68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
   2:	00 00       	nop
   4:	4c c0       	rjmp	.+152    	; 0x9e <__bad_interrupt>
   6:	00 00       	nop
   8:	4a c0       	rjmp	.+148    	; 0x9e <__bad_interrupt>
   a:	00 00       	nop
   c:	48 c0       	rjmp	.+144    	; 0x9e <__bad_interrupt>
   e:	00 00       	nop
  10:	46 c0       	rjmp	.+140    	; 0x9e <__bad_interrupt>
  12:	00 00       	nop
  14:	44 c0       	rjmp	.+136    	; 0x9e <__bad_interrupt>
  16:	00 00       	nop
  18:	42 c0       	rjmp	.+132    	; 0x9e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	40 c0       	rjmp	.+128    	; 0x9e <__bad_interrupt>
  1e:	00 00       	nop
  20:	3e c0       	rjmp	.+124    	; 0x9e <__bad_interrupt>
  22:	00 00       	nop
  24:	3c c0       	rjmp	.+120    	; 0x9e <__bad_interrupt>
  26:	00 00       	nop
  28:	3a c0       	rjmp	.+116    	; 0x9e <__bad_interrupt>
  2a:	00 00       	nop
  2c:	38 c0       	rjmp	.+112    	; 0x9e <__bad_interrupt>
  2e:	00 00       	nop
  30:	36 c0       	rjmp	.+108    	; 0x9e <__bad_interrupt>
  32:	00 00       	nop
  34:	34 c0       	rjmp	.+104    	; 0x9e <__bad_interrupt>
  36:	00 00       	nop
  38:	32 c0       	rjmp	.+100    	; 0x9e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	30 c0       	rjmp	.+96     	; 0x9e <__bad_interrupt>
  3e:	00 00       	nop
  40:	2e c0       	rjmp	.+92     	; 0x9e <__bad_interrupt>
  42:	00 00       	nop
  44:	2c c0       	rjmp	.+88     	; 0x9e <__bad_interrupt>
  46:	00 00       	nop
  48:	2a c0       	rjmp	.+84     	; 0x9e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	28 c0       	rjmp	.+80     	; 0x9e <__bad_interrupt>
  4e:	00 00       	nop
  50:	26 c0       	rjmp	.+76     	; 0x9e <__bad_interrupt>
  52:	00 00       	nop
  54:	24 c0       	rjmp	.+72     	; 0x9e <__bad_interrupt>
  56:	00 00       	nop
  58:	22 c0       	rjmp	.+68     	; 0x9e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	20 c0       	rjmp	.+64     	; 0x9e <__bad_interrupt>
  5e:	00 00       	nop
  60:	1e c0       	rjmp	.+60     	; 0x9e <__bad_interrupt>
  62:	00 00       	nop
  64:	1c c0       	rjmp	.+56     	; 0x9e <__bad_interrupt>
	...

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e4 e8       	ldi	r30, 0x84	; 132
  7c:	fa e0       	ldi	r31, 0x0A	; 10
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a8 38       	cpi	r26, 0x88	; 136
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a8 e8       	ldi	r26, 0x88	; 136
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a1 39       	cpi	r26, 0x91	; 145
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	6b d0       	rcall	.+214    	; 0x172 <main>
  9c:	f1 c4       	rjmp	.+2530   	; 0xa80 <_exit>

0000009e <__bad_interrupt>:
  9e:	b0 cf       	rjmp	.-160    	; 0x0 <__vectors>

000000a0 <spi_init>:
typedef char *string;

void spi_init()
{
	//Set MOSI, SCK and SS as output
	DDRB |= (1 << PORTB3) | (1 << PORTB5) | (1 << PORTB2);
  a0:	84 b1       	in	r24, 0x04	; 4
  a2:	8c 62       	ori	r24, 0x2C	; 44
  a4:	84 b9       	out	0x04, r24	; 4
  a6:	08 95       	ret

000000a8 <print_message>:
	lcd_puts(varData1);
	_delay_ms(1000);
}*/

void print_message(tCAN *message)
{
  a8:	df 92       	push	r13
  aa:	ef 92       	push	r14
  ac:	ff 92       	push	r15
  ae:	0f 93       	push	r16
  b0:	1f 93       	push	r17
  b2:	cf 93       	push	r28
  b4:	df 93       	push	r29
  b6:	cd b7       	in	r28, 0x3d	; 61
  b8:	de b7       	in	r29, 0x3e	; 62
  ba:	63 97       	sbiw	r28, 0x13	; 19
  bc:	0f b6       	in	r0, 0x3f	; 63
  be:	f8 94       	cli
  c0:	de bf       	out	0x3e, r29	; 62
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	cd bf       	out	0x3d, r28	; 61
  c6:	7c 01       	movw	r14, r24
	//Variable that holds the ID value received and converted with itoa function
	char varID[3];
	//Array of strings that holds the message bytes value received and converted with itoa function
	string varData[8];
	//LCD clear screen
	lcd_clrscr();
  c8:	3b d2       	rcall	.+1142   	; 0x540 <lcd_clrscr>
	lcd_home();
  ca:	4f d2       	rcall	.+1182   	; 0x56a <lcd_home>
	lcd_puts("ID ");
  cc:	80 e0       	ldi	r24, 0x00	; 0
  ce:	91 e0       	ldi	r25, 0x01	; 1
  d0:	85 d2       	rcall	.+1290   	; 0x5dc <lcd_puts>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
  d2:	4a e0       	ldi	r20, 0x0A	; 10
  d4:	be 01       	movw	r22, r28
  d6:	6f 5f       	subi	r22, 0xFF	; 255
  d8:	7f 4f       	sbci	r23, 0xFF	; 255
  da:	f7 01       	movw	r30, r14
  dc:	80 81       	ld	r24, Z
  de:	91 81       	ldd	r25, Z+1	; 0x01
  e0:	9c d4       	rcall	.+2360   	; 0xa1a <__itoa_ncheck>
	itoa(message->id, varID, 10);
	lcd_gotoxy(3, 0);
  e2:	60 e0       	ldi	r22, 0x00	; 0
  e4:	83 e0       	ldi	r24, 0x03	; 3
  e6:	1a d2       	rcall	.+1076   	; 0x51c <lcd_gotoxy>
	lcd_puts(varID);
  e8:	ce 01       	movw	r24, r28
  ea:	01 96       	adiw	r24, 0x01	; 1
  ec:	77 d2       	rcall	.+1262   	; 0x5dc <lcd_puts>
	for(lcdCellCounter = 0;lcdCellCounter < 1;lcdCellCounter++)
	{
		lcd_gotoxy(lcdCellCounter, 1);
  ee:	61 e0       	ldi	r22, 0x01	; 1
  f0:	80 e0       	ldi	r24, 0x00	; 0
  f2:	14 d2       	rcall	.+1064   	; 0x51c <lcd_gotoxy>
		for(counter = 0;counter < message->header.length;counter++)
  f4:	f7 01       	movw	r30, r14
  f6:	82 81       	ldd	r24, Z+2	; 0x02
  f8:	86 95       	lsr	r24
  fa:	8f 70       	andi	r24, 0x0F	; 15
  fc:	61 f1       	breq	.+88     	; 0x156 <print_message+0xae>
  fe:	20 e0       	ldi	r18, 0x00	; 0
 100:	30 e0       	ldi	r19, 0x00	; 0
 102:	d1 2c       	mov	r13, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 104:	ff ef       	ldi	r31, 0xFF	; 255
 106:	43 ed       	ldi	r20, 0xD3	; 211
 108:	80 e3       	ldi	r24, 0x30	; 48
 10a:	f1 50       	subi	r31, 0x01	; 1
 10c:	40 40       	sbci	r20, 0x00	; 0
 10e:	80 40       	sbci	r24, 0x00	; 0
 110:	e1 f7       	brne	.-8      	; 0x10a <print_message+0x62>
 112:	00 c0       	rjmp	.+0      	; 0x114 <print_message+0x6c>
 114:	00 00       	nop
		{
			_delay_ms(1000);
			itoa(message->data[counter], varData[counter], 10);
 116:	f9 01       	movw	r30, r18
 118:	ee 0f       	add	r30, r30
 11a:	ff 1f       	adc	r31, r31
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	8c 0f       	add	r24, r28
 122:	9d 1f       	adc	r25, r29
 124:	e8 0f       	add	r30, r24
 126:	f9 1f       	adc	r31, r25
 128:	03 81       	ldd	r16, Z+3	; 0x03
 12a:	14 81       	ldd	r17, Z+4	; 0x04
 12c:	f7 01       	movw	r30, r14
 12e:	e2 0f       	add	r30, r18
 130:	f3 1f       	adc	r31, r19
 132:	83 81       	ldd	r24, Z+3	; 0x03
 134:	4a e0       	ldi	r20, 0x0A	; 10
 136:	b8 01       	movw	r22, r16
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	6f d4       	rcall	.+2270   	; 0xa1a <__itoa_ncheck>
			lcd_puts(varData[counter]);
 13c:	c8 01       	movw	r24, r16
 13e:	4e d2       	rcall	.+1180   	; 0x5dc <lcd_puts>
	lcd_gotoxy(3, 0);
	lcd_puts(varID);
	for(lcdCellCounter = 0;lcdCellCounter < 1;lcdCellCounter++)
	{
		lcd_gotoxy(lcdCellCounter, 1);
		for(counter = 0;counter < message->header.length;counter++)
 140:	d3 94       	inc	r13
 142:	2d 2d       	mov	r18, r13
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	f7 01       	movw	r30, r14
 148:	82 81       	ldd	r24, Z+2	; 0x02
 14a:	86 95       	lsr	r24
 14c:	8f 70       	andi	r24, 0x0F	; 15
 14e:	90 e0       	ldi	r25, 0x00	; 0
 150:	28 17       	cp	r18, r24
 152:	39 07       	cpc	r19, r25
 154:	bc f2       	brlt	.-82     	; 0x104 <print_message+0x5c>
			_delay_ms(1000);
			itoa(message->data[counter], varData[counter], 10);
			lcd_puts(varData[counter]);
		}
	}
}
 156:	63 96       	adiw	r28, 0x13	; 19
 158:	0f b6       	in	r0, 0x3f	; 63
 15a:	f8 94       	cli
 15c:	de bf       	out	0x3e, r29	; 62
 15e:	0f be       	out	0x3f, r0	; 63
 160:	cd bf       	out	0x3d, r28	; 61
 162:	df 91       	pop	r29
 164:	cf 91       	pop	r28
 166:	1f 91       	pop	r17
 168:	0f 91       	pop	r16
 16a:	ff 90       	pop	r15
 16c:	ef 90       	pop	r14
 16e:	df 90       	pop	r13
 170:	08 95       	ret

00000172 <main>:

int main(void)
{
 172:	cf 93       	push	r28
 174:	df 93       	push	r29
 176:	cd b7       	in	r28, 0x3d	; 61
 178:	de b7       	in	r29, 0x3e	; 62
 17a:	2b 97       	sbiw	r28, 0x0b	; 11
 17c:	0f b6       	in	r0, 0x3f	; 63
 17e:	f8 94       	cli
 180:	de bf       	out	0x3e, r29	; 62
 182:	0f be       	out	0x3f, r0	; 63
 184:	cd bf       	out	0x3d, r28	; 61
	//Enable interrupts
	sei();
 186:	78 94       	sei
	//LCD initialization with display ON, cursor OFF, blink char
	lcd_init(LCD_DISP_ON);
 188:	8c e0       	ldi	r24, 0x0C	; 12
 18a:	37 d2       	rcall	.+1134   	; 0x5fa <lcd_init>
	//Variable which turn on/off the LCD backlight (0 = ON, 1 = OFF)
	uint8_t led = 0;
	//Turn on the backlight
	lcd_led(led);
 18c:	80 e0       	ldi	r24, 0x00	; 0
 18e:	db d1       	rcall	.+950    	; 0x546 <lcd_led>
	//SPI initialization
	spi_init();
 190:	87 df       	rcall	.-242    	; 0xa0 <spi_init>
	//MCP2515 initialization
	if(!mcp2515_init())
 192:	b1 d2       	rcall	.+1378   	; 0x6f6 <mcp2515_init>
 194:	81 11       	cpse	r24, r1
 196:	0e c0       	rjmp	.+28     	; 0x1b4 <main+0x42>
	{
		//LCD clear screen
		lcd_clrscr();
 198:	d3 d1       	rcall	.+934    	; 0x540 <lcd_clrscr>
		//Set cursor on line 1
		lcd_gotoxy(3, 0);
 19a:	60 e0       	ldi	r22, 0x00	; 0
 19c:	83 e0       	ldi	r24, 0x03	; 3
 19e:	be d1       	rcall	.+892    	; 0x51c <lcd_gotoxy>
		lcd_puts("Error CAN Bus");
 1a0:	84 e0       	ldi	r24, 0x04	; 4
 1a2:	91 e0       	ldi	r25, 0x01	; 1
 1a4:	1b d2       	rcall	.+1078   	; 0x5dc <lcd_puts>
		lcd_gotoxy(3, 1);
 1a6:	61 e0       	ldi	r22, 0x01	; 1
 1a8:	83 e0       	ldi	r24, 0x03	; 3
 1aa:	b8 d1       	rcall	.+880    	; 0x51c <lcd_gotoxy>
		lcd_puts("not initialized");
 1ac:	82 e1       	ldi	r24, 0x12	; 18
 1ae:	91 e0       	ldi	r25, 0x01	; 1
 1b0:	15 d2       	rcall	.+1066   	; 0x5dc <lcd_puts>
 1b2:	16 c0       	rjmp	.+44     	; 0x1e0 <main+0x6e>
	}
	else
	{
		//LCD clear screen
		lcd_clrscr();
 1b4:	c5 d1       	rcall	.+906    	; 0x540 <lcd_clrscr>
		//Set cursor on line 1
		lcd_gotoxy(7, 0);
 1b6:	60 e0       	ldi	r22, 0x00	; 0
 1b8:	87 e0       	ldi	r24, 0x07	; 7
 1ba:	b0 d1       	rcall	.+864    	; 0x51c <lcd_gotoxy>
		lcd_puts("CAN Bus");
 1bc:	8a e0       	ldi	r24, 0x0A	; 10
 1be:	91 e0       	ldi	r25, 0x01	; 1
 1c0:	0d d2       	rcall	.+1050   	; 0x5dc <lcd_puts>
 1c2:	2f ef       	ldi	r18, 0xFF	; 255
 1c4:	89 e6       	ldi	r24, 0x69	; 105
 1c6:	98 e1       	ldi	r25, 0x18	; 24
 1c8:	21 50       	subi	r18, 0x01	; 1
 1ca:	80 40       	sbci	r24, 0x00	; 0
 1cc:	90 40       	sbci	r25, 0x00	; 0
 1ce:	e1 f7       	brne	.-8      	; 0x1c8 <main+0x56>
 1d0:	00 c0       	rjmp	.+0      	; 0x1d2 <main+0x60>
 1d2:	00 00       	nop
		_delay_ms(500);
		//Set cursor on line 2
		lcd_gotoxy(5, 1);
 1d4:	61 e0       	ldi	r22, 0x01	; 1
 1d6:	85 e0       	ldi	r24, 0x05	; 5
 1d8:	a1 d1       	rcall	.+834    	; 0x51c <lcd_gotoxy>
		lcd_puts("initialized");
 1da:	86 e1       	ldi	r24, 0x16	; 22
 1dc:	91 e0       	ldi	r25, 0x01	; 1
 1de:	fe d1       	rcall	.+1020   	; 0x5dc <lcd_puts>
 1e0:	2f ef       	ldi	r18, 0xFF	; 255
 1e2:	87 ea       	ldi	r24, 0xA7	; 167
 1e4:	91 e6       	ldi	r25, 0x61	; 97
 1e6:	21 50       	subi	r18, 0x01	; 1
 1e8:	80 40       	sbci	r24, 0x00	; 0
 1ea:	90 40       	sbci	r25, 0x00	; 0
 1ec:	e1 f7       	brne	.-8      	; 0x1e6 <main+0x74>
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <main+0x7e>
 1f0:	00 00       	nop
	
	_delay_ms(2000);
	
	//Test message
	tCAN testMessage;
	testMessage.id = 123;
 1f2:	8b e7       	ldi	r24, 0x7B	; 123
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	9a 83       	std	Y+2, r25	; 0x02
 1f8:	89 83       	std	Y+1, r24	; 0x01
	testMessage.header.length = 2;
 1fa:	8b 81       	ldd	r24, Y+3	; 0x03
 1fc:	81 7e       	andi	r24, 0xE1	; 225
	testMessage.header.rtr = 0;
 1fe:	84 60       	ori	r24, 0x04	; 4
 200:	8e 7f       	andi	r24, 0xFE	; 254
 202:	8b 83       	std	Y+3, r24	; 0x03
	testMessage.data[0] = 0xAB;
 204:	8b ea       	ldi	r24, 0xAB	; 171
 206:	8c 83       	std	Y+4, r24	; 0x04
	testMessage.data[1] = 0xCD;
 208:	8d ec       	ldi	r24, 0xCD	; 205
 20a:	8d 83       	std	Y+5, r24	; 0x05
	
	//Switch to Loopback Mode
	mcp2515_bit_modify(CANCTRL, (1 << REQOP2) | (1 << REQOP1) | (1 << REQOP0), (1 << REQOP1));
 20c:	40 e4       	ldi	r20, 0x40	; 64
 20e:	60 ee       	ldi	r22, 0xE0	; 224
 210:	8f e0       	ldi	r24, 0x0F	; 15
 212:	57 d2       	rcall	.+1198   	; 0x6c2 <mcp2515_bit_modify>
	
	//Send message
	if(mcp2515_send_message(&testMessage))
 214:	ce 01       	movw	r24, r28
 216:	01 96       	adiw	r24, 0x01	; 1
 218:	1e d3       	rcall	.+1596   	; 0x856 <mcp2515_send_message>
 21a:	88 23       	and	r24, r24
 21c:	61 f0       	breq	.+24     	; 0x236 <main+0xc4>
	{
		//LCD clear screen
		lcd_clrscr();
 21e:	90 d1       	rcall	.+800    	; 0x540 <lcd_clrscr>
		lcd_home();
 220:	a4 d1       	rcall	.+840    	; 0x56a <lcd_home>
		lcd_puts("Message writenn");
 222:	82 e2       	ldi	r24, 0x22	; 34
 224:	91 e0       	ldi	r25, 0x01	; 1
 226:	da d1       	rcall	.+948    	; 0x5dc <lcd_puts>
		lcd_gotoxy(0, 1);
 228:	61 e0       	ldi	r22, 0x01	; 1
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	77 d1       	rcall	.+750    	; 0x51c <lcd_gotoxy>
		lcd_puts("to buffer");
 22e:	82 e3       	ldi	r24, 0x32	; 50
 230:	91 e0       	ldi	r25, 0x01	; 1
 232:	d4 d1       	rcall	.+936    	; 0x5dc <lcd_puts>
 234:	0b c0       	rjmp	.+22     	; 0x24c <main+0xda>
	}
	else
	{
		//LCD clear screen
		lcd_clrscr();
 236:	84 d1       	rcall	.+776    	; 0x540 <lcd_clrscr>
		lcd_home();
 238:	98 d1       	rcall	.+816    	; 0x56a <lcd_home>
		lcd_puts("Message not written");
 23a:	8c e3       	ldi	r24, 0x3C	; 60
 23c:	91 e0       	ldi	r25, 0x01	; 1
 23e:	ce d1       	rcall	.+924    	; 0x5dc <lcd_puts>
		lcd_gotoxy(0, 1);
 240:	61 e0       	ldi	r22, 0x01	; 1
 242:	80 e0       	ldi	r24, 0x00	; 0
 244:	6b d1       	rcall	.+726    	; 0x51c <lcd_gotoxy>
		lcd_puts("to buffer");
 246:	82 e3       	ldi	r24, 0x32	; 50
 248:	91 e0       	ldi	r25, 0x01	; 1
 24a:	c8 d1       	rcall	.+912    	; 0x5dc <lcd_puts>
 24c:	8f e3       	ldi	r24, 0x3F	; 63
 24e:	9c e9       	ldi	r25, 0x9C	; 156
 250:	01 97       	sbiw	r24, 0x01	; 1
 252:	f1 f7       	brne	.-4      	; 0x250 <main+0xde>
 254:	00 c0       	rjmp	.+0      	; 0x256 <main+0xe4>
 256:	00 00       	nop
 258:	9f ef       	ldi	r25, 0xFF	; 255
 25a:	23 ed       	ldi	r18, 0xD3	; 211
 25c:	80 e3       	ldi	r24, 0x30	; 48
 25e:	91 50       	subi	r25, 0x01	; 1
 260:	20 40       	sbci	r18, 0x00	; 0
 262:	80 40       	sbci	r24, 0x00	; 0
 264:	e1 f7       	brne	.-8      	; 0x25e <main+0xec>
 266:	00 c0       	rjmp	.+0      	; 0x268 <main+0xf6>
 268:	00 00       	nop
	
	_delay_ms(10);
	
	_delay_ms(1000);
	
	if(mcp2515_check_message())
 26a:	81 d2       	rcall	.+1282   	; 0x76e <mcp2515_check_message>
 26c:	88 23       	and	r24, r24
 26e:	e9 f0       	breq	.+58     	; 0x2aa <main+0x138>
	{
		//LCD clear screen
		lcd_clrscr();
 270:	67 d1       	rcall	.+718    	; 0x540 <lcd_clrscr>
		lcd_home();
 272:	7b d1       	rcall	.+758    	; 0x56a <lcd_home>
		lcd_puts("Message received");
 274:	80 e5       	ldi	r24, 0x50	; 80
 276:	91 e0       	ldi	r25, 0x01	; 1
 278:	b1 d1       	rcall	.+866    	; 0x5dc <lcd_puts>
 27a:	9f ef       	ldi	r25, 0xFF	; 255
 27c:	23 ed       	ldi	r18, 0xD3	; 211
 27e:	80 e3       	ldi	r24, 0x30	; 48
 280:	91 50       	subi	r25, 0x01	; 1
 282:	20 40       	sbci	r18, 0x00	; 0
 284:	80 40       	sbci	r24, 0x00	; 0
 286:	e1 f7       	brne	.-8      	; 0x280 <main+0x10e>
 288:	00 c0       	rjmp	.+0      	; 0x28a <main+0x118>
 28a:	00 00       	nop
		_delay_ms(1000);
		if(mcp2515_get_message(&testMessage))
 28c:	ce 01       	movw	r24, r28
 28e:	01 96       	adiw	r24, 0x01	; 1
 290:	75 d2       	rcall	.+1258   	; 0x77c <mcp2515_get_message>
 292:	88 23       	and	r24, r24
 294:	29 f0       	breq	.+10     	; 0x2a0 <main+0x12e>
		{
			//LCD clear screen
			lcd_clrscr();
 296:	54 d1       	rcall	.+680    	; 0x540 <lcd_clrscr>
			//Display message on the LCD
			print_message(&testMessage);
 298:	ce 01       	movw	r24, r28
 29a:	01 96       	adiw	r24, 0x01	; 1
 29c:	05 df       	rcall	.-502    	; 0xa8 <print_message>
 29e:	0a c0       	rjmp	.+20     	; 0x2b4 <main+0x142>
		}
		else
		{
			//LCD clear screen
			lcd_clrscr();
 2a0:	4f d1       	rcall	.+670    	; 0x540 <lcd_clrscr>
			//"Message not read"
			lcd_puts("Message not read");
 2a2:	81 e6       	ldi	r24, 0x61	; 97
 2a4:	91 e0       	ldi	r25, 0x01	; 1
 2a6:	9a d1       	rcall	.+820    	; 0x5dc <lcd_puts>
 2a8:	fa cf       	rjmp	.-12     	; 0x29e <main+0x12c>
		}
	}
	else
	{
		//LCD clear screen
		lcd_clrscr();
 2aa:	4a d1       	rcall	.+660    	; 0x540 <lcd_clrscr>
		//"Message not received"
		lcd_puts("Message not received");
 2ac:	82 e7       	ldi	r24, 0x72	; 114
 2ae:	91 e0       	ldi	r25, 0x01	; 1
 2b0:	95 d1       	rcall	.+810    	; 0x5dc <lcd_puts>
 2b2:	f5 cf       	rjmp	.-22     	; 0x29e <main+0x12c>
 2b4:	ff cf       	rjmp	.-2      	; 0x2b4 <main+0x142>

000002b6 <i2c_init>:
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );

}/* i2c_rep_start */
 2b6:	10 92 b9 00 	sts	0x00B9, r1
 2ba:	88 e4       	ldi	r24, 0x48	; 72
 2bc:	80 93 b8 00 	sts	0x00B8, r24
 2c0:	08 95       	ret

000002c2 <i2c_start>:
 2c2:	94 ea       	ldi	r25, 0xA4	; 164
 2c4:	90 93 bc 00 	sts	0x00BC, r25
 2c8:	ec eb       	ldi	r30, 0xBC	; 188
 2ca:	f0 e0       	ldi	r31, 0x00	; 0
 2cc:	90 81       	ld	r25, Z
 2ce:	99 23       	and	r25, r25
 2d0:	ec f7       	brge	.-6      	; 0x2cc <i2c_start+0xa>
 2d2:	90 91 b9 00 	lds	r25, 0x00B9
 2d6:	98 7f       	andi	r25, 0xF8	; 248
 2d8:	98 30       	cpi	r25, 0x08	; 8
 2da:	11 f0       	breq	.+4      	; 0x2e0 <i2c_start+0x1e>
 2dc:	90 31       	cpi	r25, 0x10	; 16
 2de:	a1 f4       	brne	.+40     	; 0x308 <i2c_start+0x46>
 2e0:	80 93 bb 00 	sts	0x00BB, r24
 2e4:	84 e8       	ldi	r24, 0x84	; 132
 2e6:	80 93 bc 00 	sts	0x00BC, r24
 2ea:	ec eb       	ldi	r30, 0xBC	; 188
 2ec:	f0 e0       	ldi	r31, 0x00	; 0
 2ee:	80 81       	ld	r24, Z
 2f0:	88 23       	and	r24, r24
 2f2:	ec f7       	brge	.-6      	; 0x2ee <i2c_start+0x2c>
 2f4:	90 91 b9 00 	lds	r25, 0x00B9
 2f8:	98 7f       	andi	r25, 0xF8	; 248
 2fa:	98 31       	cpi	r25, 0x18	; 24
 2fc:	39 f0       	breq	.+14     	; 0x30c <i2c_start+0x4a>
 2fe:	81 e0       	ldi	r24, 0x01	; 1
 300:	90 34       	cpi	r25, 0x40	; 64
 302:	29 f4       	brne	.+10     	; 0x30e <i2c_start+0x4c>
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	08 95       	ret
 308:	81 e0       	ldi	r24, 0x01	; 1
 30a:	08 95       	ret
 30c:	80 e0       	ldi	r24, 0x00	; 0
 30e:	08 95       	ret

00000310 <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 310:	84 e9       	ldi	r24, 0x94	; 148
 312:	80 93 bc 00 	sts	0x00BC, r24
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
 316:	ec eb       	ldi	r30, 0xBC	; 188
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	80 81       	ld	r24, Z
 31c:	84 fd       	sbrc	r24, 4
 31e:	fd cf       	rjmp	.-6      	; 0x31a <i2c_stop+0xa>

}/* i2c_stop */
 320:	08 95       	ret

00000322 <i2c_write>:
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
 322:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
 326:	84 e8       	ldi	r24, 0x84	; 132
 328:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 32c:	ec eb       	ldi	r30, 0xBC	; 188
 32e:	f0 e0       	ldi	r31, 0x00	; 0
 330:	80 81       	ld	r24, Z
 332:	88 23       	and	r24, r24
 334:	ec f7       	brge	.-6      	; 0x330 <i2c_write+0xe>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
 336:	90 91 b9 00 	lds	r25, 0x00B9
 33a:	98 7f       	andi	r25, 0xF8	; 248
	if( twst != TW_MT_DATA_ACK) return 1;
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	98 32       	cpi	r25, 0x28	; 40
 340:	09 f4       	brne	.+2      	; 0x344 <i2c_write+0x22>
 342:	80 e0       	ldi	r24, 0x00	; 0
	return 0;

}/* i2c_write */
 344:	08 95       	ret

00000346 <lcd_read>:

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
    }

}/* lcd_puts_p */
 346:	cf 93       	push	r28
 348:	88 23       	and	r24, r24
 34a:	31 f0       	breq	.+12     	; 0x358 <lcd_read+0x12>
 34c:	80 91 88 01 	lds	r24, 0x0188
 350:	81 60       	ori	r24, 0x01	; 1
 352:	80 93 88 01 	sts	0x0188, r24
 356:	05 c0       	rjmp	.+10     	; 0x362 <lcd_read+0x1c>
 358:	80 91 88 01 	lds	r24, 0x0188
 35c:	8e 7f       	andi	r24, 0xFE	; 254
 35e:	80 93 88 01 	sts	0x0188, r24
 362:	80 91 88 01 	lds	r24, 0x0188
 366:	82 60       	ori	r24, 0x02	; 2
 368:	80 93 88 01 	sts	0x0188, r24
 36c:	60 91 88 01 	lds	r22, 0x0188
 370:	80 e0       	ldi	r24, 0x00	; 0
 372:	06 d3       	rcall	.+1548   	; 0x980 <pcf8574_setoutput>
 374:	62 e0       	ldi	r22, 0x02	; 2
 376:	80 e0       	ldi	r24, 0x00	; 0
 378:	4a d3       	rcall	.+1684   	; 0xa0e <pcf8574_setoutputpinhigh>
 37a:	00 c0       	rjmp	.+0      	; 0x37c <lcd_read+0x36>
 37c:	64 e0       	ldi	r22, 0x04	; 4
 37e:	80 e0       	ldi	r24, 0x00	; 0
 380:	e8 d2       	rcall	.+1488   	; 0x952 <pcf8574_getoutputpin>
 382:	c8 2f       	mov	r28, r24
 384:	62 e0       	ldi	r22, 0x02	; 2
 386:	80 e0       	ldi	r24, 0x00	; 0
 388:	45 d3       	rcall	.+1674   	; 0xa14 <pcf8574_setoutputpinlow>
 38a:	00 c0       	rjmp	.+0      	; 0x38c <lcd_read+0x46>
 38c:	62 e0       	ldi	r22, 0x02	; 2
 38e:	80 e0       	ldi	r24, 0x00	; 0
 390:	3e d3       	rcall	.+1660   	; 0xa0e <pcf8574_setoutputpinhigh>
 392:	00 c0       	rjmp	.+0      	; 0x394 <lcd_read+0x4e>
 394:	64 e0       	ldi	r22, 0x04	; 4
 396:	80 e0       	ldi	r24, 0x00	; 0
 398:	dc d2       	rcall	.+1464   	; 0x952 <pcf8574_getoutputpin>
 39a:	c2 95       	swap	r28
 39c:	c0 7f       	andi	r28, 0xF0	; 240
 39e:	8f 70       	andi	r24, 0x0F	; 15
 3a0:	c8 2b       	or	r28, r24
 3a2:	62 e0       	ldi	r22, 0x02	; 2
 3a4:	80 e0       	ldi	r24, 0x00	; 0
 3a6:	36 d3       	rcall	.+1644   	; 0xa14 <pcf8574_setoutputpinlow>
 3a8:	8c 2f       	mov	r24, r28
 3aa:	cf 91       	pop	r28
 3ac:	08 95       	ret

000003ae <lcd_waitbusy>:
 3ae:	80 e0       	ldi	r24, 0x00	; 0
 3b0:	ca df       	rcall	.-108    	; 0x346 <lcd_read>
 3b2:	88 23       	and	r24, r24
 3b4:	e4 f3       	brlt	.-8      	; 0x3ae <lcd_waitbusy>
 3b6:	88 e0       	ldi	r24, 0x08	; 8
 3b8:	90 e0       	ldi	r25, 0x00	; 0
 3ba:	01 97       	sbiw	r24, 0x01	; 1
 3bc:	f1 f7       	brne	.-4      	; 0x3ba <lcd_waitbusy+0xc>
 3be:	80 e0       	ldi	r24, 0x00	; 0
 3c0:	c2 cf       	rjmp	.-124    	; 0x346 <lcd_read>
 3c2:	08 95       	ret

000003c4 <toggle_e>:
 3c4:	62 e0       	ldi	r22, 0x02	; 2
 3c6:	80 e0       	ldi	r24, 0x00	; 0
 3c8:	22 d3       	rcall	.+1604   	; 0xa0e <pcf8574_setoutputpinhigh>
 3ca:	00 c0       	rjmp	.+0      	; 0x3cc <toggle_e+0x8>
 3cc:	62 e0       	ldi	r22, 0x02	; 2
 3ce:	80 e0       	ldi	r24, 0x00	; 0
 3d0:	21 c3       	rjmp	.+1602   	; 0xa14 <pcf8574_setoutputpinlow>
 3d2:	08 95       	ret

000003d4 <lcd_write>:
 3d4:	cf 93       	push	r28
 3d6:	c8 2f       	mov	r28, r24
 3d8:	66 23       	and	r22, r22
 3da:	31 f0       	breq	.+12     	; 0x3e8 <lcd_write+0x14>
 3dc:	80 91 88 01 	lds	r24, 0x0188
 3e0:	81 60       	ori	r24, 0x01	; 1
 3e2:	80 93 88 01 	sts	0x0188, r24
 3e6:	05 c0       	rjmp	.+10     	; 0x3f2 <lcd_write+0x1e>
 3e8:	80 91 88 01 	lds	r24, 0x0188
 3ec:	8e 7f       	andi	r24, 0xFE	; 254
 3ee:	80 93 88 01 	sts	0x0188, r24
 3f2:	80 91 88 01 	lds	r24, 0x0188
 3f6:	8d 7f       	andi	r24, 0xFD	; 253
 3f8:	80 93 88 01 	sts	0x0188, r24
 3fc:	60 91 88 01 	lds	r22, 0x0188
 400:	80 e0       	ldi	r24, 0x00	; 0
 402:	be d2       	rcall	.+1404   	; 0x980 <pcf8574_setoutput>
 404:	80 91 88 01 	lds	r24, 0x0188
 408:	8f 77       	andi	r24, 0x7F	; 127
 40a:	80 93 88 01 	sts	0x0188, r24
 40e:	80 91 88 01 	lds	r24, 0x0188
 412:	8f 7b       	andi	r24, 0xBF	; 191
 414:	80 93 88 01 	sts	0x0188, r24
 418:	80 91 88 01 	lds	r24, 0x0188
 41c:	8f 7d       	andi	r24, 0xDF	; 223
 41e:	80 93 88 01 	sts	0x0188, r24
 422:	80 91 88 01 	lds	r24, 0x0188
 426:	8f 7e       	andi	r24, 0xEF	; 239
 428:	80 93 88 01 	sts	0x0188, r24
 42c:	cc 23       	and	r28, r28
 42e:	2c f4       	brge	.+10     	; 0x43a <lcd_write+0x66>
 430:	80 91 88 01 	lds	r24, 0x0188
 434:	80 68       	ori	r24, 0x80	; 128
 436:	80 93 88 01 	sts	0x0188, r24
 43a:	c6 ff       	sbrs	r28, 6
 43c:	05 c0       	rjmp	.+10     	; 0x448 <lcd_write+0x74>
 43e:	80 91 88 01 	lds	r24, 0x0188
 442:	80 64       	ori	r24, 0x40	; 64
 444:	80 93 88 01 	sts	0x0188, r24
 448:	c5 ff       	sbrs	r28, 5
 44a:	05 c0       	rjmp	.+10     	; 0x456 <lcd_write+0x82>
 44c:	80 91 88 01 	lds	r24, 0x0188
 450:	80 62       	ori	r24, 0x20	; 32
 452:	80 93 88 01 	sts	0x0188, r24
 456:	c4 ff       	sbrs	r28, 4
 458:	05 c0       	rjmp	.+10     	; 0x464 <lcd_write+0x90>
 45a:	80 91 88 01 	lds	r24, 0x0188
 45e:	80 61       	ori	r24, 0x10	; 16
 460:	80 93 88 01 	sts	0x0188, r24
 464:	60 91 88 01 	lds	r22, 0x0188
 468:	80 e0       	ldi	r24, 0x00	; 0
 46a:	8a d2       	rcall	.+1300   	; 0x980 <pcf8574_setoutput>
 46c:	ab df       	rcall	.-170    	; 0x3c4 <toggle_e>
 46e:	80 91 88 01 	lds	r24, 0x0188
 472:	8f 77       	andi	r24, 0x7F	; 127
 474:	80 93 88 01 	sts	0x0188, r24
 478:	80 91 88 01 	lds	r24, 0x0188
 47c:	8f 7b       	andi	r24, 0xBF	; 191
 47e:	80 93 88 01 	sts	0x0188, r24
 482:	80 91 88 01 	lds	r24, 0x0188
 486:	8f 7d       	andi	r24, 0xDF	; 223
 488:	80 93 88 01 	sts	0x0188, r24
 48c:	80 91 88 01 	lds	r24, 0x0188
 490:	8f 7e       	andi	r24, 0xEF	; 239
 492:	80 93 88 01 	sts	0x0188, r24
 496:	c3 ff       	sbrs	r28, 3
 498:	05 c0       	rjmp	.+10     	; 0x4a4 <lcd_write+0xd0>
 49a:	80 91 88 01 	lds	r24, 0x0188
 49e:	80 68       	ori	r24, 0x80	; 128
 4a0:	80 93 88 01 	sts	0x0188, r24
 4a4:	c2 ff       	sbrs	r28, 2
 4a6:	05 c0       	rjmp	.+10     	; 0x4b2 <lcd_write+0xde>
 4a8:	80 91 88 01 	lds	r24, 0x0188
 4ac:	80 64       	ori	r24, 0x40	; 64
 4ae:	80 93 88 01 	sts	0x0188, r24
 4b2:	c1 ff       	sbrs	r28, 1
 4b4:	05 c0       	rjmp	.+10     	; 0x4c0 <lcd_write+0xec>
 4b6:	80 91 88 01 	lds	r24, 0x0188
 4ba:	80 62       	ori	r24, 0x20	; 32
 4bc:	80 93 88 01 	sts	0x0188, r24
 4c0:	c0 ff       	sbrs	r28, 0
 4c2:	05 c0       	rjmp	.+10     	; 0x4ce <lcd_write+0xfa>
 4c4:	80 91 88 01 	lds	r24, 0x0188
 4c8:	80 61       	ori	r24, 0x10	; 16
 4ca:	80 93 88 01 	sts	0x0188, r24
 4ce:	60 91 88 01 	lds	r22, 0x0188
 4d2:	80 e0       	ldi	r24, 0x00	; 0
 4d4:	55 d2       	rcall	.+1194   	; 0x980 <pcf8574_setoutput>
 4d6:	76 df       	rcall	.-276    	; 0x3c4 <toggle_e>
 4d8:	80 91 88 01 	lds	r24, 0x0188
 4dc:	80 61       	ori	r24, 0x10	; 16
 4de:	80 93 88 01 	sts	0x0188, r24
 4e2:	80 91 88 01 	lds	r24, 0x0188
 4e6:	80 62       	ori	r24, 0x20	; 32
 4e8:	80 93 88 01 	sts	0x0188, r24
 4ec:	80 91 88 01 	lds	r24, 0x0188
 4f0:	80 64       	ori	r24, 0x40	; 64
 4f2:	80 93 88 01 	sts	0x0188, r24
 4f6:	80 91 88 01 	lds	r24, 0x0188
 4fa:	80 68       	ori	r24, 0x80	; 128
 4fc:	80 93 88 01 	sts	0x0188, r24
 500:	60 91 88 01 	lds	r22, 0x0188
 504:	80 e0       	ldi	r24, 0x00	; 0
 506:	3c d2       	rcall	.+1144   	; 0x980 <pcf8574_setoutput>
 508:	cf 91       	pop	r28
 50a:	08 95       	ret

0000050c <lcd_command>:
 50c:	cf 93       	push	r28
 50e:	c8 2f       	mov	r28, r24
 510:	4e df       	rcall	.-356    	; 0x3ae <lcd_waitbusy>
 512:	60 e0       	ldi	r22, 0x00	; 0
 514:	8c 2f       	mov	r24, r28
 516:	5e df       	rcall	.-324    	; 0x3d4 <lcd_write>
 518:	cf 91       	pop	r28
 51a:	08 95       	ret

0000051c <lcd_gotoxy>:
 51c:	61 11       	cpse	r22, r1
 51e:	03 c0       	rjmp	.+6      	; 0x526 <lcd_gotoxy+0xa>
 520:	80 58       	subi	r24, 0x80	; 128
 522:	f4 cf       	rjmp	.-24     	; 0x50c <lcd_command>
 524:	08 95       	ret
 526:	61 30       	cpi	r22, 0x01	; 1
 528:	19 f4       	brne	.+6      	; 0x530 <lcd_gotoxy+0x14>
 52a:	80 54       	subi	r24, 0x40	; 64
 52c:	ef cf       	rjmp	.-34     	; 0x50c <lcd_command>
 52e:	08 95       	ret
 530:	62 30       	cpi	r22, 0x02	; 2
 532:	19 f4       	brne	.+6      	; 0x53a <lcd_gotoxy+0x1e>
 534:	8c 56       	subi	r24, 0x6C	; 108
 536:	ea cf       	rjmp	.-44     	; 0x50c <lcd_command>
 538:	08 95       	ret
 53a:	8c 52       	subi	r24, 0x2C	; 44
 53c:	e7 cf       	rjmp	.-50     	; 0x50c <lcd_command>
 53e:	08 95       	ret

00000540 <lcd_clrscr>:
 540:	81 e0       	ldi	r24, 0x01	; 1
 542:	e4 cf       	rjmp	.-56     	; 0x50c <lcd_command>
 544:	08 95       	ret

00000546 <lcd_led>:
 546:	88 23       	and	r24, r24
 548:	31 f0       	breq	.+12     	; 0x556 <lcd_led+0x10>
 54a:	80 91 88 01 	lds	r24, 0x0188
 54e:	87 7f       	andi	r24, 0xF7	; 247
 550:	80 93 88 01 	sts	0x0188, r24
 554:	05 c0       	rjmp	.+10     	; 0x560 <lcd_led+0x1a>
 556:	80 91 88 01 	lds	r24, 0x0188
 55a:	88 60       	ori	r24, 0x08	; 8
 55c:	80 93 88 01 	sts	0x0188, r24
 560:	60 91 88 01 	lds	r22, 0x0188
 564:	80 e0       	ldi	r24, 0x00	; 0
 566:	0c c2       	rjmp	.+1048   	; 0x980 <pcf8574_setoutput>
 568:	08 95       	ret

0000056a <lcd_home>:
 56a:	82 e0       	ldi	r24, 0x02	; 2
 56c:	cf cf       	rjmp	.-98     	; 0x50c <lcd_command>
 56e:	08 95       	ret

00000570 <lcd_putc>:
 570:	cf 93       	push	r28
 572:	c8 2f       	mov	r28, r24
 574:	1c df       	rcall	.-456    	; 0x3ae <lcd_waitbusy>
 576:	ca 30       	cpi	r28, 0x0A	; 10
 578:	a1 f4       	brne	.+40     	; 0x5a2 <lcd_putc+0x32>
 57a:	84 31       	cpi	r24, 0x14	; 20
 57c:	50 f0       	brcs	.+20     	; 0x592 <lcd_putc+0x22>
 57e:	90 ec       	ldi	r25, 0xC0	; 192
 580:	98 0f       	add	r25, r24
 582:	94 31       	cpi	r25, 0x14	; 20
 584:	40 f0       	brcs	.+16     	; 0x596 <lcd_putc+0x26>
 586:	9c ee       	ldi	r25, 0xEC	; 236
 588:	98 0f       	add	r25, r24
 58a:	9c 32       	cpi	r25, 0x2C	; 44
 58c:	30 f4       	brcc	.+12     	; 0x59a <lcd_putc+0x2a>
 58e:	84 e5       	ldi	r24, 0x54	; 84
 590:	05 c0       	rjmp	.+10     	; 0x59c <lcd_putc+0x2c>
 592:	80 e4       	ldi	r24, 0x40	; 64
 594:	03 c0       	rjmp	.+6      	; 0x59c <lcd_putc+0x2c>
 596:	84 e1       	ldi	r24, 0x14	; 20
 598:	01 c0       	rjmp	.+2      	; 0x59c <lcd_putc+0x2c>
 59a:	80 e0       	ldi	r24, 0x00	; 0
 59c:	80 58       	subi	r24, 0x80	; 128
 59e:	b6 df       	rcall	.-148    	; 0x50c <lcd_command>
 5a0:	1b c0       	rjmp	.+54     	; 0x5d8 <lcd_putc+0x68>
 5a2:	84 31       	cpi	r24, 0x14	; 20
 5a4:	21 f4       	brne	.+8      	; 0x5ae <lcd_putc+0x3e>
 5a6:	60 e0       	ldi	r22, 0x00	; 0
 5a8:	80 ec       	ldi	r24, 0xC0	; 192
 5aa:	14 df       	rcall	.-472    	; 0x3d4 <lcd_write>
 5ac:	11 c0       	rjmp	.+34     	; 0x5d0 <lcd_putc+0x60>
 5ae:	84 35       	cpi	r24, 0x54	; 84
 5b0:	21 f4       	brne	.+8      	; 0x5ba <lcd_putc+0x4a>
 5b2:	60 e0       	ldi	r22, 0x00	; 0
 5b4:	84 e9       	ldi	r24, 0x94	; 148
 5b6:	0e df       	rcall	.-484    	; 0x3d4 <lcd_write>
 5b8:	0b c0       	rjmp	.+22     	; 0x5d0 <lcd_putc+0x60>
 5ba:	88 32       	cpi	r24, 0x28	; 40
 5bc:	21 f4       	brne	.+8      	; 0x5c6 <lcd_putc+0x56>
 5be:	60 e0       	ldi	r22, 0x00	; 0
 5c0:	84 ed       	ldi	r24, 0xD4	; 212
 5c2:	08 df       	rcall	.-496    	; 0x3d4 <lcd_write>
 5c4:	05 c0       	rjmp	.+10     	; 0x5d0 <lcd_putc+0x60>
 5c6:	88 36       	cpi	r24, 0x68	; 104
 5c8:	19 f4       	brne	.+6      	; 0x5d0 <lcd_putc+0x60>
 5ca:	60 e0       	ldi	r22, 0x00	; 0
 5cc:	80 e8       	ldi	r24, 0x80	; 128
 5ce:	02 df       	rcall	.-508    	; 0x3d4 <lcd_write>
 5d0:	ee de       	rcall	.-548    	; 0x3ae <lcd_waitbusy>
 5d2:	61 e0       	ldi	r22, 0x01	; 1
 5d4:	8c 2f       	mov	r24, r28
 5d6:	fe de       	rcall	.-516    	; 0x3d4 <lcd_write>
 5d8:	cf 91       	pop	r28
 5da:	08 95       	ret

000005dc <lcd_puts>:
 5dc:	cf 93       	push	r28
 5de:	df 93       	push	r29
 5e0:	ec 01       	movw	r28, r24
 5e2:	21 96       	adiw	r28, 0x01	; 1
 5e4:	fc 01       	movw	r30, r24
 5e6:	80 81       	ld	r24, Z
 5e8:	88 23       	and	r24, r24
 5ea:	21 f0       	breq	.+8      	; 0x5f4 <lcd_puts+0x18>
 5ec:	c1 df       	rcall	.-126    	; 0x570 <lcd_putc>
 5ee:	89 91       	ld	r24, Y+
 5f0:	81 11       	cpse	r24, r1
 5f2:	fc cf       	rjmp	.-8      	; 0x5ec <lcd_puts+0x10>
 5f4:	df 91       	pop	r29
 5f6:	cf 91       	pop	r28
 5f8:	08 95       	ret

000005fa <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 5fa:	cf 93       	push	r28
 5fc:	c8 2f       	mov	r28, r24
	#if LCD_PCF8574_INIT == 1
	//init pcf8574
	pcf8574_init();
 5fe:	99 d1       	rcall	.+818    	; 0x932 <pcf8574_init>
	#endif

	dataport = 0;
 600:	10 92 88 01 	sts	0x0188, r1
	pcf8574_setoutput(LCD_PCF8574_DEVICEID, dataport);
 604:	60 91 88 01 	lds	r22, 0x0188
 608:	80 e0       	ldi	r24, 0x00	; 0
 60a:	ba d1       	rcall	.+884    	; 0x980 <pcf8574_setoutput>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 60c:	e0 e0       	ldi	r30, 0x00	; 0
 60e:	fa ef       	ldi	r31, 0xFA	; 250
 610:	31 97       	sbiw	r30, 0x01	; 1
 612:	f1 f7       	brne	.-4      	; 0x610 <lcd_init+0x16>
	pcf8574_setoutput(LCD_PCF8574_DEVICEID, dataport);

    delay(16000);        /* wait 16ms or more after power-on       */

    /* initial write to lcd is 8bit */
    dataport |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
 614:	80 91 88 01 	lds	r24, 0x0188
 618:	80 62       	ori	r24, 0x20	; 32
 61a:	80 93 88 01 	sts	0x0188, r24
    dataport |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
 61e:	80 91 88 01 	lds	r24, 0x0188
 622:	80 61       	ori	r24, 0x10	; 16
 624:	80 93 88 01 	sts	0x0188, r24
    pcf8574_setoutput(LCD_PCF8574_DEVICEID, dataport);
 628:	60 91 88 01 	lds	r22, 0x0188
 62c:	80 e0       	ldi	r24, 0x00	; 0
 62e:	a8 d1       	rcall	.+848    	; 0x980 <pcf8574_setoutput>

    lcd_e_toggle();
 630:	c9 de       	rcall	.-622    	; 0x3c4 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 632:	e0 e0       	ldi	r30, 0x00	; 0
 634:	fe e4       	ldi	r31, 0x4E	; 78
 636:	31 97       	sbiw	r30, 0x01	; 1
 638:	f1 f7       	brne	.-4      	; 0x636 <lcd_init+0x3c>

    lcd_e_toggle();
    delay(4992);         /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
 63a:	c4 de       	rcall	.-632    	; 0x3c4 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 63c:	e0 e0       	ldi	r30, 0x00	; 0
 63e:	f1 e0       	ldi	r31, 0x01	; 1
 640:	31 97       	sbiw	r30, 0x01	; 1
 642:	f1 f7       	brne	.-4      	; 0x640 <lcd_init+0x46>
    /* repeat last command */ 
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
 644:	bf de       	rcall	.-642    	; 0x3c4 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 646:	e0 e0       	ldi	r30, 0x00	; 0
 648:	f1 e0       	ldi	r31, 0x01	; 1
 64a:	31 97       	sbiw	r30, 0x01	; 1
 64c:	f1 f7       	brne	.-4      	; 0x64a <lcd_init+0x50>
    /* repeat last command a third time */
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    dataport &= ~_BV(LCD_DATA0_PIN);
 64e:	80 91 88 01 	lds	r24, 0x0188
 652:	8f 7e       	andi	r24, 0xEF	; 239
 654:	80 93 88 01 	sts	0x0188, r24
    pcf8574_setoutput(LCD_PCF8574_DEVICEID, dataport);
 658:	60 91 88 01 	lds	r22, 0x0188
 65c:	80 e0       	ldi	r24, 0x00	; 0
 65e:	90 d1       	rcall	.+800    	; 0x980 <pcf8574_setoutput>
    lcd_e_toggle();
 660:	b1 de       	rcall	.-670    	; 0x3c4 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 662:	e0 e0       	ldi	r30, 0x00	; 0
 664:	f1 e0       	ldi	r31, 0x01	; 1
 666:	31 97       	sbiw	r30, 0x01	; 1
 668:	f1 f7       	brne	.-4      	; 0x666 <lcd_init+0x6c>
    lcd_e_toggle();
    delay(64);           /* some displays need this additional delay */
    
    /* from now the LCD only accepts 4 bit I/O, we can use lcd_command() */    

    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 66a:	88 e2       	ldi	r24, 0x28	; 40
 66c:	4f df       	rcall	.-354    	; 0x50c <lcd_command>

    lcd_command(LCD_DISP_OFF);              /* display off                  */
 66e:	88 e0       	ldi	r24, 0x08	; 8
 670:	4d df       	rcall	.-358    	; 0x50c <lcd_command>
    lcd_clrscr();                           /* display clear                */
 672:	66 df       	rcall	.-308    	; 0x540 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 674:	86 e0       	ldi	r24, 0x06	; 6
 676:	4a df       	rcall	.-364    	; 0x50c <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
 678:	8c 2f       	mov	r24, r28
 67a:	48 df       	rcall	.-368    	; 0x50c <lcd_command>

}/* lcd_init */
 67c:	cf 91       	pop	r28
 67e:	08 95       	ret

00000680 <spi_putc>:
		// all buffers used
		return false;
	}
	
	return true;
}
 680:	8e bd       	out	0x2e, r24	; 46
 682:	0d b4       	in	r0, 0x2d	; 45
 684:	07 fe       	sbrs	r0, 7
 686:	fd cf       	rjmp	.-6      	; 0x682 <spi_putc+0x2>
 688:	8e b5       	in	r24, 0x2e	; 46
 68a:	08 95       	ret

0000068c <mcp2515_write_register>:
 68c:	cf 93       	push	r28
 68e:	df 93       	push	r29
 690:	d8 2f       	mov	r29, r24
 692:	c6 2f       	mov	r28, r22
 694:	2a 98       	cbi	0x05, 2	; 5
 696:	82 e0       	ldi	r24, 0x02	; 2
 698:	f3 df       	rcall	.-26     	; 0x680 <spi_putc>
 69a:	8d 2f       	mov	r24, r29
 69c:	f1 df       	rcall	.-30     	; 0x680 <spi_putc>
 69e:	8c 2f       	mov	r24, r28
 6a0:	ef df       	rcall	.-34     	; 0x680 <spi_putc>
 6a2:	2a 9a       	sbi	0x05, 2	; 5
 6a4:	df 91       	pop	r29
 6a6:	cf 91       	pop	r28
 6a8:	08 95       	ret

000006aa <mcp2515_read_register>:
 6aa:	cf 93       	push	r28
 6ac:	c8 2f       	mov	r28, r24
 6ae:	2a 98       	cbi	0x05, 2	; 5
 6b0:	83 e0       	ldi	r24, 0x03	; 3
 6b2:	e6 df       	rcall	.-52     	; 0x680 <spi_putc>
 6b4:	8c 2f       	mov	r24, r28
 6b6:	e4 df       	rcall	.-56     	; 0x680 <spi_putc>
 6b8:	8f ef       	ldi	r24, 0xFF	; 255
 6ba:	e2 df       	rcall	.-60     	; 0x680 <spi_putc>
 6bc:	2a 9a       	sbi	0x05, 2	; 5
 6be:	cf 91       	pop	r28
 6c0:	08 95       	ret

000006c2 <mcp2515_bit_modify>:
 6c2:	1f 93       	push	r17
 6c4:	cf 93       	push	r28
 6c6:	df 93       	push	r29
 6c8:	18 2f       	mov	r17, r24
 6ca:	d6 2f       	mov	r29, r22
 6cc:	c4 2f       	mov	r28, r20
 6ce:	2a 98       	cbi	0x05, 2	; 5
 6d0:	85 e0       	ldi	r24, 0x05	; 5
 6d2:	d6 df       	rcall	.-84     	; 0x680 <spi_putc>
 6d4:	81 2f       	mov	r24, r17
 6d6:	d4 df       	rcall	.-88     	; 0x680 <spi_putc>
 6d8:	8d 2f       	mov	r24, r29
 6da:	d2 df       	rcall	.-92     	; 0x680 <spi_putc>
 6dc:	8c 2f       	mov	r24, r28
 6de:	d0 df       	rcall	.-96     	; 0x680 <spi_putc>
 6e0:	2a 9a       	sbi	0x05, 2	; 5
 6e2:	df 91       	pop	r29
 6e4:	cf 91       	pop	r28
 6e6:	1f 91       	pop	r17
 6e8:	08 95       	ret

000006ea <mcp2515_read_status>:
 6ea:	2a 98       	cbi	0x05, 2	; 5
 6ec:	c9 df       	rcall	.-110    	; 0x680 <spi_putc>
 6ee:	8f ef       	ldi	r24, 0xFF	; 255
 6f0:	c7 df       	rcall	.-114    	; 0x680 <spi_putc>
 6f2:	2a 9a       	sbi	0x05, 2	; 5
 6f4:	08 95       	ret

000006f6 <mcp2515_init>:
 6f6:	2a 9a       	sbi	0x05, 2	; 5
 6f8:	22 9a       	sbi	0x04, 2	; 4
 6fa:	2d 98       	cbi	0x05, 5	; 5
 6fc:	2b 98       	cbi	0x05, 3	; 5
 6fe:	2c 98       	cbi	0x05, 4	; 5
 700:	25 9a       	sbi	0x04, 5	; 4
 702:	23 9a       	sbi	0x04, 3	; 4
 704:	24 98       	cbi	0x04, 4	; 4
 706:	52 98       	cbi	0x0a, 2	; 10
 708:	5a 9a       	sbi	0x0b, 2	; 11
 70a:	81 e5       	ldi	r24, 0x51	; 81
 70c:	8c bd       	out	0x2c, r24	; 44
 70e:	1d bc       	out	0x2d, r1	; 45
 710:	2a 98       	cbi	0x05, 2	; 5
 712:	80 ec       	ldi	r24, 0xC0	; 192
 714:	b5 df       	rcall	.-150    	; 0x680 <spi_putc>
 716:	2a 9a       	sbi	0x05, 2	; 5
 718:	8f e3       	ldi	r24, 0x3F	; 63
 71a:	9c e9       	ldi	r25, 0x9C	; 156
 71c:	01 97       	sbiw	r24, 0x01	; 1
 71e:	f1 f7       	brne	.-4      	; 0x71c <mcp2515_init+0x26>
 720:	00 c0       	rjmp	.+0      	; 0x722 <mcp2515_init+0x2c>
 722:	00 00       	nop
 724:	2a 98       	cbi	0x05, 2	; 5
 726:	82 e0       	ldi	r24, 0x02	; 2
 728:	ab df       	rcall	.-170    	; 0x680 <spi_putc>
 72a:	88 e2       	ldi	r24, 0x28	; 40
 72c:	a9 df       	rcall	.-174    	; 0x680 <spi_putc>
 72e:	82 e0       	ldi	r24, 0x02	; 2
 730:	a7 df       	rcall	.-178    	; 0x680 <spi_putc>
 732:	80 e9       	ldi	r24, 0x90	; 144
 734:	a5 df       	rcall	.-182    	; 0x680 <spi_putc>
 736:	87 e0       	ldi	r24, 0x07	; 7
 738:	a3 df       	rcall	.-186    	; 0x680 <spi_putc>
 73a:	83 e0       	ldi	r24, 0x03	; 3
 73c:	a1 df       	rcall	.-190    	; 0x680 <spi_putc>
 73e:	2a 9a       	sbi	0x05, 2	; 5
 740:	8a e2       	ldi	r24, 0x2A	; 42
 742:	b3 df       	rcall	.-154    	; 0x6aa <mcp2515_read_register>
 744:	87 30       	cpi	r24, 0x07	; 7
 746:	89 f4       	brne	.+34     	; 0x76a <mcp2515_init+0x74>
 748:	60 e0       	ldi	r22, 0x00	; 0
 74a:	8c e0       	ldi	r24, 0x0C	; 12
 74c:	9f df       	rcall	.-194    	; 0x68c <mcp2515_write_register>
 74e:	60 e0       	ldi	r22, 0x00	; 0
 750:	8d e0       	ldi	r24, 0x0D	; 13
 752:	9c df       	rcall	.-200    	; 0x68c <mcp2515_write_register>
 754:	60 e6       	ldi	r22, 0x60	; 96
 756:	80 e6       	ldi	r24, 0x60	; 96
 758:	99 df       	rcall	.-206    	; 0x68c <mcp2515_write_register>
 75a:	60 e6       	ldi	r22, 0x60	; 96
 75c:	80 e7       	ldi	r24, 0x70	; 112
 75e:	96 df       	rcall	.-212    	; 0x68c <mcp2515_write_register>
 760:	60 e0       	ldi	r22, 0x00	; 0
 762:	8f e0       	ldi	r24, 0x0F	; 15
 764:	93 df       	rcall	.-218    	; 0x68c <mcp2515_write_register>
 766:	81 e0       	ldi	r24, 0x01	; 1
 768:	08 95       	ret
 76a:	80 e0       	ldi	r24, 0x00	; 0
 76c:	08 95       	ret

0000076e <mcp2515_check_message>:
 76e:	89 b1       	in	r24, 0x09	; 9
 770:	82 fb       	bst	r24, 2
 772:	88 27       	eor	r24, r24
 774:	80 f9       	bld	r24, 0
 776:	91 e0       	ldi	r25, 0x01	; 1
 778:	89 27       	eor	r24, r25
 77a:	08 95       	ret

0000077c <mcp2515_get_message>:

// ----------------------------------------------------------------------------
uint8_t mcp2515_get_message(tCAN *message)
{
 77c:	ef 92       	push	r14
 77e:	ff 92       	push	r15
 780:	0f 93       	push	r16
 782:	1f 93       	push	r17
 784:	cf 93       	push	r28
 786:	df 93       	push	r29
 788:	1f 92       	push	r1
 78a:	cd b7       	in	r28, 0x3d	; 61
 78c:	de b7       	in	r29, 0x3e	; 62
 78e:	7c 01       	movw	r14, r24
	// read status
	uint8_t status = mcp2515_read_status(SPI_RX_STATUS);
 790:	80 eb       	ldi	r24, 0xB0	; 176
 792:	ab df       	rcall	.-170    	; 0x6ea <mcp2515_read_status>
 794:	89 83       	std	Y+1, r24	; 0x01
	uint8_t addr;
	
	if (bit_is_set(status,6)) {
 796:	89 81       	ldd	r24, Y+1	; 0x01
 798:	86 fd       	sbrc	r24, 6
 79a:	06 c0       	rjmp	.+12     	; 0x7a8 <mcp2515_get_message+0x2c>
		// message in buffer 0
		addr = SPI_READ_RX;
	}
	else if (bit_is_set(status,7)) {
 79c:	89 81       	ldd	r24, Y+1	; 0x01
 79e:	88 23       	and	r24, r24
 7a0:	0c f0       	brlt	.+2      	; 0x7a4 <mcp2515_get_message+0x28>
 7a2:	50 c0       	rjmp	.+160    	; 0x844 <mcp2515_get_message+0xc8>
		// message in buffer 1
		addr = SPI_READ_RX | 0x04;
 7a4:	84 e9       	ldi	r24, 0x94	; 148
 7a6:	01 c0       	rjmp	.+2      	; 0x7aa <mcp2515_get_message+0x2e>
	uint8_t status = mcp2515_read_status(SPI_RX_STATUS);
	uint8_t addr;
	
	if (bit_is_set(status,6)) {
		// message in buffer 0
		addr = SPI_READ_RX;
 7a8:	80 e9       	ldi	r24, 0x90	; 144
	else {
		// Error: no message available
		return 0;
	}

	RESET(MCP2515_CS);
 7aa:	2a 98       	cbi	0x05, 2	; 5
	spi_putc(addr);
 7ac:	69 df       	rcall	.-302    	; 0x680 <spi_putc>
	
	// read id
	message->id  = (uint16_t) spi_putc(0xff) << 3;
 7ae:	8f ef       	ldi	r24, 0xFF	; 255
 7b0:	67 df       	rcall	.-306    	; 0x680 <spi_putc>
 7b2:	98 e0       	ldi	r25, 0x08	; 8
 7b4:	89 9f       	mul	r24, r25
 7b6:	80 01       	movw	r16, r0
 7b8:	11 24       	eor	r1, r1
 7ba:	f7 01       	movw	r30, r14
 7bc:	11 83       	std	Z+1, r17	; 0x01
 7be:	00 83       	st	Z, r16
	message->id |=            spi_putc(0xff) >> 5;
 7c0:	8f ef       	ldi	r24, 0xFF	; 255
 7c2:	5e df       	rcall	.-324    	; 0x680 <spi_putc>
 7c4:	82 95       	swap	r24
 7c6:	86 95       	lsr	r24
 7c8:	87 70       	andi	r24, 0x07	; 7
 7ca:	08 2b       	or	r16, r24
 7cc:	f7 01       	movw	r30, r14
 7ce:	11 83       	std	Z+1, r17	; 0x01
 7d0:	00 83       	st	Z, r16
	
	spi_putc(0xff);
 7d2:	8f ef       	ldi	r24, 0xFF	; 255
 7d4:	55 df       	rcall	.-342    	; 0x680 <spi_putc>
	spi_putc(0xff);
 7d6:	8f ef       	ldi	r24, 0xFF	; 255
 7d8:	53 df       	rcall	.-346    	; 0x680 <spi_putc>
	
	// read DLC
	uint8_t length = spi_putc(0xff) & 0x0f;
 7da:	8f ef       	ldi	r24, 0xFF	; 255
 7dc:	51 df       	rcall	.-350    	; 0x680 <spi_putc>
 7de:	8f 70       	andi	r24, 0x0F	; 15
	
	message->header.length = length;
 7e0:	28 2f       	mov	r18, r24
 7e2:	22 0f       	add	r18, r18
 7e4:	f7 01       	movw	r30, r14
 7e6:	92 81       	ldd	r25, Z+2	; 0x02
 7e8:	91 7e       	andi	r25, 0xE1	; 225
 7ea:	92 2b       	or	r25, r18
 7ec:	92 83       	std	Z+2, r25	; 0x02
	message->header.rtr = (bit_is_set(status, 3)) ? 1 : 0;
 7ee:	29 81       	ldd	r18, Y+1	; 0x01
 7f0:	23 fb       	bst	r18, 3
 7f2:	22 27       	eor	r18, r18
 7f4:	20 f9       	bld	r18, 0
 7f6:	20 fb       	bst	r18, 0
 7f8:	90 f9       	bld	r25, 0
 7fa:	92 83       	std	Z+2, r25	; 0x02
	
	// read data
	for (uint8_t i=0;i<length;i++) {
 7fc:	88 23       	and	r24, r24
 7fe:	89 f0       	breq	.+34     	; 0x822 <mcp2515_get_message+0xa6>
 800:	87 01       	movw	r16, r14
 802:	0d 5f       	subi	r16, 0xFD	; 253
 804:	1f 4f       	sbci	r17, 0xFF	; 255
 806:	f4 e0       	ldi	r31, 0x04	; 4
 808:	ef 0e       	add	r14, r31
 80a:	f1 1c       	adc	r15, r1
 80c:	81 50       	subi	r24, 0x01	; 1
 80e:	e8 0e       	add	r14, r24
 810:	f1 1c       	adc	r15, r1
		message->data[i] = spi_putc(0xff);
 812:	8f ef       	ldi	r24, 0xFF	; 255
 814:	35 df       	rcall	.-406    	; 0x680 <spi_putc>
 816:	f8 01       	movw	r30, r16
 818:	81 93       	st	Z+, r24
 81a:	8f 01       	movw	r16, r30
	
	message->header.length = length;
	message->header.rtr = (bit_is_set(status, 3)) ? 1 : 0;
	
	// read data
	for (uint8_t i=0;i<length;i++) {
 81c:	ee 15       	cp	r30, r14
 81e:	ff 05       	cpc	r31, r15
 820:	c1 f7       	brne	.-16     	; 0x812 <mcp2515_get_message+0x96>
		message->data[i] = spi_putc(0xff);
	}
	SET(MCP2515_CS);
 822:	2a 9a       	sbi	0x05, 2	; 5
	
	// clear interrupt flag
	if (bit_is_set(status, 6)) {
 824:	89 81       	ldd	r24, Y+1	; 0x01
 826:	86 ff       	sbrs	r24, 6
 828:	05 c0       	rjmp	.+10     	; 0x834 <mcp2515_get_message+0xb8>
		mcp2515_bit_modify(CANINTF, (1<<RX0IF), 0);
 82a:	40 e0       	ldi	r20, 0x00	; 0
 82c:	61 e0       	ldi	r22, 0x01	; 1
 82e:	8c e2       	ldi	r24, 0x2C	; 44
 830:	48 df       	rcall	.-368    	; 0x6c2 <mcp2515_bit_modify>
 832:	04 c0       	rjmp	.+8      	; 0x83c <mcp2515_get_message+0xc0>
	}
	else {
		mcp2515_bit_modify(CANINTF, (1<<RX1IF), 0);
 834:	40 e0       	ldi	r20, 0x00	; 0
 836:	62 e0       	ldi	r22, 0x02	; 2
 838:	8c e2       	ldi	r24, 0x2C	; 44
 83a:	43 df       	rcall	.-378    	; 0x6c2 <mcp2515_bit_modify>
	}
	
	return (status & 0x07) + 1;
 83c:	89 81       	ldd	r24, Y+1	; 0x01
 83e:	87 70       	andi	r24, 0x07	; 7
 840:	8f 5f       	subi	r24, 0xFF	; 255
 842:	01 c0       	rjmp	.+2      	; 0x846 <mcp2515_get_message+0xca>
		// message in buffer 1
		addr = SPI_READ_RX | 0x04;
	}
	else {
		// Error: no message available
		return 0;
 844:	80 e0       	ldi	r24, 0x00	; 0
	else {
		mcp2515_bit_modify(CANINTF, (1<<RX1IF), 0);
	}
	
	return (status & 0x07) + 1;
}
 846:	0f 90       	pop	r0
 848:	df 91       	pop	r29
 84a:	cf 91       	pop	r28
 84c:	1f 91       	pop	r17
 84e:	0f 91       	pop	r16
 850:	ff 90       	pop	r15
 852:	ef 90       	pop	r14
 854:	08 95       	ret

00000856 <mcp2515_send_message>:

// ----------------------------------------------------------------------------
uint8_t mcp2515_send_message(tCAN *message)
{
 856:	df 92       	push	r13
 858:	ef 92       	push	r14
 85a:	ff 92       	push	r15
 85c:	0f 93       	push	r16
 85e:	1f 93       	push	r17
 860:	cf 93       	push	r28
 862:	df 93       	push	r29
 864:	1f 92       	push	r1
 866:	cd b7       	in	r28, 0x3d	; 61
 868:	de b7       	in	r29, 0x3e	; 62
 86a:	8c 01       	movw	r16, r24
	uint8_t status = mcp2515_read_status(SPI_READ_STATUS);
 86c:	80 ea       	ldi	r24, 0xA0	; 160
 86e:	3d df       	rcall	.-390    	; 0x6ea <mcp2515_read_status>
 870:	89 83       	std	Y+1, r24	; 0x01
	 *  2	TXB0CNTRL.TXREQ
	 *  4	TXB1CNTRL.TXREQ
	 *  6	TXB2CNTRL.TXREQ
	 */
	uint8_t address;
	if (bit_is_clear(status, 2)) {
 872:	89 81       	ldd	r24, Y+1	; 0x01
 874:	82 ff       	sbrs	r24, 2
 876:	0a c0       	rjmp	.+20     	; 0x88c <mcp2515_send_message+0x36>
		address = 0x00;
	}
	else if (bit_is_clear(status, 4)) {
 878:	89 81       	ldd	r24, Y+1	; 0x01
 87a:	84 ff       	sbrs	r24, 4
 87c:	09 c0       	rjmp	.+18     	; 0x890 <mcp2515_send_message+0x3a>
		address = 0x02;
	} 
	else if (bit_is_clear(status, 6)) {
 87e:	89 81       	ldd	r24, Y+1	; 0x01
 880:	86 fd       	sbrc	r24, 6
 882:	4d c0       	rjmp	.+154    	; 0x91e <__stack+0x1f>
		address = 0x04;
 884:	68 94       	set
 886:	dd 24       	eor	r13, r13
 888:	d2 f8       	bld	r13, 2
 88a:	05 c0       	rjmp	.+10     	; 0x896 <mcp2515_send_message+0x40>
	 *  4	TXB1CNTRL.TXREQ
	 *  6	TXB2CNTRL.TXREQ
	 */
	uint8_t address;
	if (bit_is_clear(status, 2)) {
		address = 0x00;
 88c:	d1 2c       	mov	r13, r1
 88e:	03 c0       	rjmp	.+6      	; 0x896 <mcp2515_send_message+0x40>
	}
	else if (bit_is_clear(status, 4)) {
		address = 0x02;
 890:	68 94       	set
 892:	dd 24       	eor	r13, r13
 894:	d1 f8       	bld	r13, 1
	else {
		// all buffer used => could not send message
		return 0;
	}
	
	RESET(MCP2515_CS);
 896:	2a 98       	cbi	0x05, 2	; 5
	spi_putc(SPI_WRITE_TX | address);
 898:	8d 2d       	mov	r24, r13
 89a:	80 64       	ori	r24, 0x40	; 64
 89c:	f1 de       	rcall	.-542    	; 0x680 <spi_putc>
	
	spi_putc(message->id >> 3);
 89e:	f8 01       	movw	r30, r16
 8a0:	20 81       	ld	r18, Z
 8a2:	31 81       	ldd	r19, Z+1	; 0x01
 8a4:	c9 01       	movw	r24, r18
 8a6:	96 95       	lsr	r25
 8a8:	87 95       	ror	r24
 8aa:	96 95       	lsr	r25
 8ac:	87 95       	ror	r24
 8ae:	96 95       	lsr	r25
 8b0:	87 95       	ror	r24
 8b2:	e6 de       	rcall	.-564    	; 0x680 <spi_putc>
    spi_putc(message->id << 5);
 8b4:	f8 01       	movw	r30, r16
 8b6:	80 81       	ld	r24, Z
 8b8:	82 95       	swap	r24
 8ba:	88 0f       	add	r24, r24
 8bc:	80 7e       	andi	r24, 0xE0	; 224
 8be:	e0 de       	rcall	.-576    	; 0x680 <spi_putc>
	
	spi_putc(0);
 8c0:	80 e0       	ldi	r24, 0x00	; 0
 8c2:	de de       	rcall	.-580    	; 0x680 <spi_putc>
	spi_putc(0);
 8c4:	80 e0       	ldi	r24, 0x00	; 0
 8c6:	dc de       	rcall	.-584    	; 0x680 <spi_putc>
	
	uint8_t length = message->header.length & 0x0f;
 8c8:	f8 01       	movw	r30, r16
 8ca:	82 81       	ldd	r24, Z+2	; 0x02
 8cc:	e8 2e       	mov	r14, r24
 8ce:	e6 94       	lsr	r14
 8d0:	fe 2d       	mov	r31, r14
 8d2:	ff 70       	andi	r31, 0x0F	; 15
 8d4:	ef 2e       	mov	r14, r31
	
	if (message->header.rtr) {
 8d6:	80 ff       	sbrs	r24, 0
 8d8:	04 c0       	rjmp	.+8      	; 0x8e2 <mcp2515_send_message+0x8c>
		// a rtr-frame has a length, but contains no data
		spi_putc((1<<RTR) | length);
 8da:	8f 2f       	mov	r24, r31
 8dc:	80 64       	ori	r24, 0x40	; 64
 8de:	d0 de       	rcall	.-608    	; 0x680 <spi_putc>
 8e0:	0e c0       	rjmp	.+28     	; 0x8fe <mcp2515_send_message+0xa8>
	}
	else {
		// set message length
		spi_putc(length);
 8e2:	8f 2f       	mov	r24, r31
 8e4:	cd de       	rcall	.-614    	; 0x680 <spi_putc>
		
		// data
		for (uint8_t i=0;i<length;i++) {
 8e6:	ee 20       	and	r14, r14
 8e8:	51 f0       	breq	.+20     	; 0x8fe <mcp2515_send_message+0xa8>
 8ea:	0d 5f       	subi	r16, 0xFD	; 253
 8ec:	1f 4f       	sbci	r17, 0xFF	; 255
 8ee:	f1 2c       	mov	r15, r1
			spi_putc(message->data[i]);
 8f0:	f8 01       	movw	r30, r16
 8f2:	81 91       	ld	r24, Z+
 8f4:	8f 01       	movw	r16, r30
 8f6:	c4 de       	rcall	.-632    	; 0x680 <spi_putc>
	else {
		// set message length
		spi_putc(length);
		
		// data
		for (uint8_t i=0;i<length;i++) {
 8f8:	f3 94       	inc	r15
 8fa:	fe 14       	cp	r15, r14
 8fc:	c8 f3       	brcs	.-14     	; 0x8f0 <mcp2515_send_message+0x9a>
			spi_putc(message->data[i]);
		}
	}
	SET(MCP2515_CS);
 8fe:	2a 9a       	sbi	0x05, 2	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 900:	f5 e0       	ldi	r31, 0x05	; 5
 902:	fa 95       	dec	r31
 904:	f1 f7       	brne	.-4      	; 0x902 <__stack+0x3>
 906:	00 00       	nop
	
	_delay_us(1);
	
	// send message
	RESET(MCP2515_CS);
 908:	2a 98       	cbi	0x05, 2	; 5
	address = (address == 0) ? 1 : address;
 90a:	d1 10       	cpse	r13, r1
 90c:	02 c0       	rjmp	.+4      	; 0x912 <__stack+0x13>
 90e:	dd 24       	eor	r13, r13
 910:	d3 94       	inc	r13
	spi_putc(SPI_RTS | address);
 912:	8d 2d       	mov	r24, r13
 914:	80 68       	ori	r24, 0x80	; 128
 916:	b4 de       	rcall	.-664    	; 0x680 <spi_putc>
	SET(MCP2515_CS);
 918:	2a 9a       	sbi	0x05, 2	; 5
	
	return address;
 91a:	8d 2d       	mov	r24, r13
 91c:	01 c0       	rjmp	.+2      	; 0x920 <__stack+0x21>
	else if (bit_is_clear(status, 6)) {
		address = 0x04;
	}
	else {
		// all buffer used => could not send message
		return 0;
 91e:	80 e0       	ldi	r24, 0x00	; 0
	address = (address == 0) ? 1 : address;
	spi_putc(SPI_RTS | address);
	SET(MCP2515_CS);
	
	return address;
}
 920:	0f 90       	pop	r0
 922:	df 91       	pop	r29
 924:	cf 91       	pop	r28
 926:	1f 91       	pop	r17
 928:	0f 91       	pop	r16
 92a:	ff 90       	pop	r15
 92c:	ef 90       	pop	r14
 92e:	df 90       	pop	r13
 930:	08 95       	ret

00000932 <pcf8574_init>:
		i2c_write(b);
		i2c_stop();
		return 0;
	}
	return -1;
}
 932:	c1 dc       	rcall	.-1662   	; 0x2b6 <i2c_init>
 934:	85 e3       	ldi	r24, 0x35	; 53
 936:	8a 95       	dec	r24
 938:	f1 f7       	brne	.-4      	; 0x936 <pcf8574_init+0x4>
 93a:	00 00       	nop
 93c:	80 e0       	ldi	r24, 0x00	; 0
 93e:	90 e0       	ldi	r25, 0x00	; 0
 940:	fc 01       	movw	r30, r24
 942:	e7 57       	subi	r30, 0x77	; 119
 944:	fe 4f       	sbci	r31, 0xFE	; 254
 946:	10 82       	st	Z, r1
 948:	01 96       	adiw	r24, 0x01	; 1
 94a:	88 30       	cpi	r24, 0x08	; 8
 94c:	91 05       	cpc	r25, r1
 94e:	c1 f7       	brne	.-16     	; 0x940 <pcf8574_init+0xe>
 950:	08 95       	ret

00000952 <pcf8574_getoutputpin>:
 952:	88 30       	cpi	r24, 0x08	; 8
 954:	88 f4       	brcc	.+34     	; 0x978 <pcf8574_getoutputpin+0x26>
 956:	68 30       	cpi	r22, 0x08	; 8
 958:	88 f4       	brcc	.+34     	; 0x97c <pcf8574_getoutputpin+0x2a>
 95a:	e8 2f       	mov	r30, r24
 95c:	f0 e0       	ldi	r31, 0x00	; 0
 95e:	e7 57       	subi	r30, 0x77	; 119
 960:	fe 4f       	sbci	r31, 0xFE	; 254
 962:	80 81       	ld	r24, Z
 964:	99 27       	eor	r25, r25
 966:	87 fd       	sbrc	r24, 7
 968:	90 95       	com	r25
 96a:	02 c0       	rjmp	.+4      	; 0x970 <pcf8574_getoutputpin+0x1e>
 96c:	95 95       	asr	r25
 96e:	87 95       	ror	r24
 970:	6a 95       	dec	r22
 972:	e2 f7       	brpl	.-8      	; 0x96c <pcf8574_getoutputpin+0x1a>
 974:	81 70       	andi	r24, 0x01	; 1
 976:	08 95       	ret
 978:	8f ef       	ldi	r24, 0xFF	; 255
 97a:	08 95       	ret
 97c:	8f ef       	ldi	r24, 0xFF	; 255
 97e:	08 95       	ret

00000980 <pcf8574_setoutput>:
 980:	cf 93       	push	r28
 982:	c6 2f       	mov	r28, r22
 984:	88 30       	cpi	r24, 0x08	; 8
 986:	68 f4       	brcc	.+26     	; 0x9a2 <pcf8574_setoutput+0x22>
 988:	e8 2f       	mov	r30, r24
 98a:	f0 e0       	ldi	r31, 0x00	; 0
 98c:	e7 57       	subi	r30, 0x77	; 119
 98e:	fe 4f       	sbci	r31, 0xFE	; 254
 990:	60 83       	st	Z, r22
 992:	81 5c       	subi	r24, 0xC1	; 193
 994:	88 0f       	add	r24, r24
 996:	95 dc       	rcall	.-1750   	; 0x2c2 <i2c_start>
 998:	8c 2f       	mov	r24, r28
 99a:	c3 dc       	rcall	.-1658   	; 0x322 <i2c_write>
 99c:	b9 dc       	rcall	.-1678   	; 0x310 <i2c_stop>
 99e:	80 e0       	ldi	r24, 0x00	; 0
 9a0:	01 c0       	rjmp	.+2      	; 0x9a4 <pcf8574_setoutput+0x24>
 9a2:	8f ef       	ldi	r24, 0xFF	; 255
 9a4:	cf 91       	pop	r28
 9a6:	08 95       	ret

000009a8 <pcf8574_setoutputpin>:

/*
 * set output pin
 */
int8_t pcf8574_setoutputpin(uint8_t deviceid, uint8_t pin, uint8_t data) {
 9a8:	cf 93       	push	r28
	if((deviceid >= 0 && deviceid < PCF8574_MAXDEVICES) && (pin >= 0 && pin < PCF8574_MAXPINS)) {
 9aa:	88 30       	cpi	r24, 0x08	; 8
 9ac:	58 f5       	brcc	.+86     	; 0xa04 <pcf8574_setoutputpin+0x5c>
 9ae:	68 30       	cpi	r22, 0x08	; 8
 9b0:	58 f5       	brcc	.+86     	; 0xa08 <pcf8574_setoutputpin+0x60>
	    uint8_t b = 0;
	    b = pcf8574_pinstatus[deviceid];
 9b2:	28 2f       	mov	r18, r24
 9b4:	30 e0       	ldi	r19, 0x00	; 0
 9b6:	f9 01       	movw	r30, r18
 9b8:	e7 57       	subi	r30, 0x77	; 119
 9ba:	fe 4f       	sbci	r31, 0xFE	; 254
 9bc:	c0 81       	ld	r28, Z
	    b = (data != 0) ? (b | (1 << pin)) : (b & ~(1 << pin));
 9be:	44 23       	and	r20, r20
 9c0:	51 f0       	breq	.+20     	; 0x9d6 <pcf8574_setoutputpin+0x2e>
 9c2:	e1 e0       	ldi	r30, 0x01	; 1
 9c4:	f0 e0       	ldi	r31, 0x00	; 0
 9c6:	af 01       	movw	r20, r30
 9c8:	02 c0       	rjmp	.+4      	; 0x9ce <pcf8574_setoutputpin+0x26>
 9ca:	44 0f       	add	r20, r20
 9cc:	55 1f       	adc	r21, r21
 9ce:	6a 95       	dec	r22
 9d0:	e2 f7       	brpl	.-8      	; 0x9ca <pcf8574_setoutputpin+0x22>
 9d2:	c4 2b       	or	r28, r20
 9d4:	0b c0       	rjmp	.+22     	; 0x9ec <pcf8574_setoutputpin+0x44>
 9d6:	41 e0       	ldi	r20, 0x01	; 1
 9d8:	50 e0       	ldi	r21, 0x00	; 0
 9da:	fa 01       	movw	r30, r20
 9dc:	02 c0       	rjmp	.+4      	; 0x9e2 <pcf8574_setoutputpin+0x3a>
 9de:	ee 0f       	add	r30, r30
 9e0:	ff 1f       	adc	r31, r31
 9e2:	6a 95       	dec	r22
 9e4:	e2 f7       	brpl	.-8      	; 0x9de <pcf8574_setoutputpin+0x36>
 9e6:	bf 01       	movw	r22, r30
 9e8:	60 95       	com	r22
 9ea:	c6 23       	and	r28, r22
	    pcf8574_pinstatus[deviceid] = b;
 9ec:	f9 01       	movw	r30, r18
 9ee:	e7 57       	subi	r30, 0x77	; 119
 9f0:	fe 4f       	sbci	r31, 0xFE	; 254
 9f2:	c0 83       	st	Z, r28
	    //update device
		i2c_start(((PCF8574_ADDRBASE+deviceid)<<1) | I2C_WRITE);
 9f4:	81 5c       	subi	r24, 0xC1	; 193
 9f6:	88 0f       	add	r24, r24
 9f8:	64 dc       	rcall	.-1848   	; 0x2c2 <i2c_start>
		i2c_write(b);
 9fa:	8c 2f       	mov	r24, r28
 9fc:	92 dc       	rcall	.-1756   	; 0x322 <i2c_write>
		i2c_stop();
 9fe:	88 dc       	rcall	.-1776   	; 0x310 <i2c_stop>
		return 0;
 a00:	80 e0       	ldi	r24, 0x00	; 0
 a02:	03 c0       	rjmp	.+6      	; 0xa0a <pcf8574_setoutputpin+0x62>
	}
	return -1;
 a04:	8f ef       	ldi	r24, 0xFF	; 255
 a06:	01 c0       	rjmp	.+2      	; 0xa0a <pcf8574_setoutputpin+0x62>
 a08:	8f ef       	ldi	r24, 0xFF	; 255
}
 a0a:	cf 91       	pop	r28
 a0c:	08 95       	ret

00000a0e <pcf8574_setoutputpinhigh>:

/*
 * set output pin high
 */
int8_t pcf8574_setoutputpinhigh(uint8_t deviceid, uint8_t pin) {
	return pcf8574_setoutputpin(deviceid, pin, 1);
 a0e:	41 e0       	ldi	r20, 0x01	; 1
 a10:	cb cf       	rjmp	.-106    	; 0x9a8 <pcf8574_setoutputpin>
}
 a12:	08 95       	ret

00000a14 <pcf8574_setoutputpinlow>:

/*
 * set output pin low
 */
int8_t pcf8574_setoutputpinlow(uint8_t deviceid, uint8_t pin) {
	return pcf8574_setoutputpin(deviceid, pin, 0);
 a14:	40 e0       	ldi	r20, 0x00	; 0
 a16:	c8 cf       	rjmp	.-112    	; 0x9a8 <pcf8574_setoutputpin>
}
 a18:	08 95       	ret

00000a1a <__itoa_ncheck>:
 a1a:	bb 27       	eor	r27, r27
 a1c:	4a 30       	cpi	r20, 0x0A	; 10
 a1e:	31 f4       	brne	.+12     	; 0xa2c <__itoa_ncheck+0x12>
 a20:	99 23       	and	r25, r25
 a22:	22 f4       	brpl	.+8      	; 0xa2c <__itoa_ncheck+0x12>
 a24:	bd e2       	ldi	r27, 0x2D	; 45
 a26:	90 95       	com	r25
 a28:	81 95       	neg	r24
 a2a:	9f 4f       	sbci	r25, 0xFF	; 255
 a2c:	01 c0       	rjmp	.+2      	; 0xa30 <__utoa_common>

00000a2e <__utoa_ncheck>:
 a2e:	bb 27       	eor	r27, r27

00000a30 <__utoa_common>:
 a30:	fb 01       	movw	r30, r22
 a32:	55 27       	eor	r21, r21
 a34:	aa 27       	eor	r26, r26
 a36:	88 0f       	add	r24, r24
 a38:	99 1f       	adc	r25, r25
 a3a:	aa 1f       	adc	r26, r26
 a3c:	a4 17       	cp	r26, r20
 a3e:	10 f0       	brcs	.+4      	; 0xa44 <__utoa_common+0x14>
 a40:	a4 1b       	sub	r26, r20
 a42:	83 95       	inc	r24
 a44:	50 51       	subi	r21, 0x10	; 16
 a46:	b9 f7       	brne	.-18     	; 0xa36 <__utoa_common+0x6>
 a48:	a0 5d       	subi	r26, 0xD0	; 208
 a4a:	aa 33       	cpi	r26, 0x3A	; 58
 a4c:	08 f0       	brcs	.+2      	; 0xa50 <__utoa_common+0x20>
 a4e:	a9 5d       	subi	r26, 0xD9	; 217
 a50:	a1 93       	st	Z+, r26
 a52:	00 97       	sbiw	r24, 0x00	; 0
 a54:	79 f7       	brne	.-34     	; 0xa34 <__utoa_common+0x4>
 a56:	b1 11       	cpse	r27, r1
 a58:	b1 93       	st	Z+, r27
 a5a:	11 92       	st	Z+, r1
 a5c:	cb 01       	movw	r24, r22
 a5e:	00 c0       	rjmp	.+0      	; 0xa60 <strrev>

00000a60 <strrev>:
 a60:	dc 01       	movw	r26, r24
 a62:	fc 01       	movw	r30, r24
 a64:	67 2f       	mov	r22, r23
 a66:	71 91       	ld	r23, Z+
 a68:	77 23       	and	r23, r23
 a6a:	e1 f7       	brne	.-8      	; 0xa64 <strrev+0x4>
 a6c:	32 97       	sbiw	r30, 0x02	; 2
 a6e:	04 c0       	rjmp	.+8      	; 0xa78 <strrev+0x18>
 a70:	7c 91       	ld	r23, X
 a72:	6d 93       	st	X+, r22
 a74:	70 83       	st	Z, r23
 a76:	62 91       	ld	r22, -Z
 a78:	ae 17       	cp	r26, r30
 a7a:	bf 07       	cpc	r27, r31
 a7c:	c8 f3       	brcs	.-14     	; 0xa70 <strrev+0x10>
 a7e:	08 95       	ret

00000a80 <_exit>:
 a80:	f8 94       	cli

00000a82 <__stop_program>:
 a82:	ff cf       	rjmp	.-2      	; 0xa82 <__stop_program>
